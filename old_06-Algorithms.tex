\part{Algorithms}
	\chapter{Computational Complexity}
		\section{Complexity}
			The following example is for addition of two matrices: \\
			\begin{algorithm}[!ht]
				\caption{Add two $m \times n$ matrices $A$, $B$ to get matrix $C$}
				\begin{algorithmic}
					\FOR {$i=1, 2, ..., m$}
						\FOR {$j=1, 2, ..., n$}
							\STATE $C_{ij} = A_{ij} + B_{ij}$
						\ENDFOR
					\ENDFOR
				\end{algorithmic}				
			\end{algorithm}\\

			The "running time" of an algorithm is measured by the number of basic operational steps.

			For so called "basic" steps, it includes
			\begin{itemize}
				\item $+$, $-$, $\times$, $\div$
				\item assignments and storage of a variable
				\item comparisons
			\end{itemize}

			For the example above
			\begin{itemize}
				\item $c_1 m n$ for addition $C_{ij} = A_{ij} + B_{ij}$
				\item $c_2 m n$ for saving $C_{ij}$
				\item $c_3 m n$ for comparison and assignment for $i$ and $j$
			\end{itemize}
			$c_1, c_2, c_3$ does not matter, the number of steps are $m \times n$, we say the algorithm runs $O(mn)$ (big O notation, the worse case)

			\begin{example}
				$f(n) = 3n^3 + 4n^2$\\
				Claim: $f(n)$ is $O(n^3)$\\
				Proof: Find a $c$ for $cn^3 - 3n^3 - 4n^2$ that there exist a $n_0$, for $\forall n \ge n_0$, the inequality holds.
			\end{example}

		\section{O notation, Omega notation, Theta notation}
			\begin{definition}[O notation]
				An algorithm is said to run in $O(f(n))$ time if for some constant $C (\ge 0)$, and $n_0$ the time takes algorithm is at most $Cf(n)$ for all $n\ge n_0$ 
			\end{definition}

			\begin{definition}[$\Omega$ notation]
				An algorithm is said to run in $\Omega(f(n))$ time if for some constant $C^{'} (\ge 0)$, and $n_0$. For all instance $n \ge n_0$, the time takes algorithm is at least $C^{'}f(n)$ for some instances. 
			\end{definition}

			\begin{definition}[$\Theta$ notation]
				An algorithm is said to be $\Theta(f(n))$ if it is both $O(f(n))$ and $\Omega(f(n))$
			\end{definition}

			\begin{example}
				$\frac{1}{2}n^2 - 3n$, $\Omega(n^2) \le \Theta(n^2) \le O(n^2)$\\
				Find $c^{'}$ and $c$ (both > 0) where $c^{'}n^2 \le \frac{1}{2}n^2 - 3n \le cn^2$ for a given $n_0$, $\forall n\ge n_0$ the inequality holds.\\
				Let $c^{'} = \frac{1}{14}$ and $c = \frac{1}{2}$, $\forall n \ge n_0$, where $n_0 = 7$, the inequality always holds.
			\end{example}

		\section{Representation of data}
			For set $\{1, 3, 4, 6, 8\}$ we have two ways to represent, array and list.

			For array, the representation is
			\begin{figure}[!ht]
				\centering
				\begin{tikzpicture}
					\matrix [rowArray] (rowArray) {
						1 & 2 & 3 & 4 & 5 & 6 & 7 & 8\\
						1 & 0 & 1 & 1 & 0 & 1 & 0 & 1\\
					};
				\end{tikzpicture}
			\end{figure}

			For list, the representation is
			\begin{figure}[!ht]
				\centering
				\begin{tikzpicture}[every node/.style = {rectangle split, rectangle split parts = 2, rectangle split horizontal}, node distance = 1em, start chain, every join/.style = {->, shorten <= -4.5pt}]
					\node [draw, on chain, join] {1};
					\node [draw, on chain, join] {3};
					\node [draw, on chain, join] {4};
					\node [draw, on chain, join] {6};
					\node [draw, on chain, join] {8};
					\node [draw, on chain, join] {};
				\end{tikzpicture}
			\end{figure}

			There is no "better" representation, one can be better than the other one in different cases.

			\begin{example}	
				For $\emptyset$, array need to build a space with $n$ cells of 0, complexity $O(n)$, list just need to build the first cell, $O(1)$
			\end{example}

			\begin{example}
				To find if a number is in a set, array needs $O(1)$ (look at the address), list needs $O(n)$ (loop through list, worst case, entire list)
			\end{example}

		\section{Size of a problem}
			Number of bits needed to store the problem

			\begin{example}
				Let $0 \le A_{ij} \le 2^{51}$
			\end{example}

			Representation by the bits of the number, $A_{ij} \le 2^51$ can be represented by max of $O(log(A_{ij}))$, (51 bits)

			For matrix addition that the total storage for addtion two matrix is $O(mnk)$, $k=O(log|A_{mn}|)$

		\section{P and NP}
			\begin{itemize}
				\item P
				\item Co-P
				\item NP
				\item Co-NP: The class of decision problems for which a yes response corresponds to a no for answering menmber of NP.
				\begin{example}
					Given a TSP, we ask does there \textbf{not} exist a tour?
				\end{example}
			\end{itemize}

			\begin{conjecture}
				\begin{equation}
					P \ne NP
				\end{equation}
			\end{conjecture}

			\begin{definition}[polynomial reduction]
				We say a problem A polynomially reduces to problem B, if we can transform problem A into problem B in polynomial number of steps so that if solve B in poly time ,we can reconstruct solution to A in poly time.
			\end{definition}

			\begin{definition}[NP-hard]
				Problems to which all members of NP reduces to. If one of those problem can be solved in poly time, we prove that $P=NP$.
			\end{definition}

			\begin{definition}[NPC]
				Decision problems that belong to NP-hard. 
			\end{definition}

			Here are some relations between different classes of problems
			\begin{itemize}
				\item $NP \subset DP$
				\item $P \subset NP$
				\item $P \subset NP \cup Co-NP$
				\item $NP-complete = NP \cup NP-hard$
				\item $Undecide \cup NP = \emptyset$
			\end{itemize}

			Given $n$, $m$ number of variables and constants. As well as the largest const $C$ of a problem:
			\begin{itemize}
				\item All algorithm will run in poly time if the number of guess is a poly function
				\begin{example}
					$O(mn)$, $O(m + n\log C$
				\end{example}
				\item strongly poly time
				\begin{example}
					$O(n^3.5)$
				\end{example}
				\item pseudo-poly time
				\begin{example}
					$O(mn + C)$, $O(Cn)$
				\end{example}
			\end{itemize}

	\chapter{Sorting}
		\section{Elementary Sorting Algorithms}

		\section{Heap-sort}

		\section{Quick-sort}

		\section{Sorting in Linear Time}

		\section{Medians and Order Statistics}

	\chapter{Data Structures}
		\section{Elementary Data Structures}

		\section{Hash Tables}

		\section{Binary Search Trees}

		\section{Red-Black Trees}

		\section{B-Trees}

		\section{Fibonacci Heaps}

		\section{van Emde Boas Trees}

	\chapter{Design and Analysis Techniques}
		\section{Dynamic Programming}

		\section{Greedy Algorithms}

		\section{Amortized Analysis}

		\section{Multi-threaded Algorithms}

		\section{Matrix Operations}

		\section{Polynomials and the FFT}

		\section{Number-Theoretic Algorithms}

		\section{String Matching}

		\section{Computational Geometry}

		\section{NP-Completeness}

		\section{Approximation Algorithms}
